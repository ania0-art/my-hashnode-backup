---
title: "记一次从物理内存中获取内核符号表"
datePublished: Wed Jan 07 2026 11:40:52 GMT+0000 (Coordinated Universal Time)
cuid: cmk3y684t000302js7x68ek54
slug: 6k6w5lia5qyh5luo54mp55cg5yaf5a2y5lit6i635yw5yaf5qc456ym5y36kgo
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1767787748744/73cdf980-6c53-47d7-a0b8-99cac08e8653.png
tags: 5yaf5a2y5yw6kb

---

# 0.准备工作

为了从物理内存二进制视图中准确的重构出内核符号表，我们需要获取 1.msr寄存器中syscall入口地址，记为S 2.内核代码段第一页签名，记为T 通过启发式扫描、特征匹配和复杂的数据结构解析，重构出 Linux 内核的完整内存拓扑。

## msr中syscall入口地址

从vmcs数据结构中读取IA32\_LSTAR\_MSR(0XC0000082)存储有syscall入口地址

## 内核代码段第一页签名

使用gdb反汇编vmlinux内核调试包获取第一页签名。具体操作十分简单不过多赘述。

# 1.定位.text段和.rodata段

在获取了syscall入口地址后，我们可以很快速的定位到.rodata段和.text段的大致界限（更加准确的界限可以等到kallsyms重构后通过查表得到）

## 寻找.rodata段

获取了S后，我们知道S地址位于.text段，我们可以通过向高地址字节扫描，在标准的 Linux 内核链接布局中，`.rodata` 段紧随 `.text` 段之后，且 `.rodata` 的起始位置存放着内核版本字符串,例如"Linux version 5.4.0-42-generic" 。伪代码如下

```c
//以4k页为单位查找
struct KernelLayout IdentifyRoData(address_t start_gva) 
{ 
	address_t current_page; 
	while (current_page < MAX_SEARCH_LIMIT) { 
		byte* page_content = MapGuestPage(current_page); 
		if (strncmp(page_content, "Linux version ", 14) == 0)
			return { .rodata_start = current_page, .version = ver }; 
}
```

## 寻找.text段

我们可以从S开始向低地址进行字节扫描去匹配我们准备的T，伪代码如下：

```c
address_t FindKernelBase(address_t start_gva) {
    address_t current_page;
    Signature[] sigs = T;
    while (current_page > MIN_SEARCH_LIMIT) {
        byte* page_content = MapGuestPage(current_page);
        if (MatchAnySignature(page_content, sigs)) {
            return current_page; // 命中！这就是 _text (Kernel Base)
        }
}
```

# 2.重构kallsyms符号表

最关键的在于我们如何重构整个kallsyms表，首先**kallsyms** 是 Linux 内核的符号表，编译时生成并嵌入到内核镜像中。它包含：

* **符号名称**：函数名、变量名（如 `do_execve`, `init_task`）
    
* **符号地址**：每个符号在内核中的虚拟地址
    
* **符号类型**：T(text), D(data), R(rodata) 等 **内核中的 kallsyms 数据结构**（6.0版本后存在大幅度变化，出现新表以及表的排列方式存在变化）：
    

```c
// 内核编译时生成，位于 .rodata 段
kallsyms_addresses[]       // 符号地址数组（绝对地址）或
kallsyms_offsets[]         // 符号偏移数组（相对于 kallsyms_relative_base）
kallsyms_relative_base     // 相对模式的基址（通常 = kernel base）
kallsyms_num_syms          // 符号数量
kallsyms_names[]           // 符号名称（压缩存储）
kallsyms_markers[]         // 名称查找索引
kallsyms_token_table[]     // 名称解压缩用的 token 表
kallsyms_token_index[]     // token 索引
```

存在**两种 kallsyms 模式**： **绝对地址模式**（旧版内核）

* `kallsyms_addresses[]` 存储每个符号的绝对 GVA **相对偏移模式**
    
* `kallsyms_offsets[]` 存储相对于 `kallsyms_relative_base` 的偏移
    

## 相对偏移模式

以内核版本5.4.150为例

```c
//scripts/kallsyms.c中关于生成offset的逻辑(5.4.150)
  for (i = 0; i < table_cnt; i++) {
      if (base_relative) {
          long long offset;
          int overflow;

          if (!absolute_percpu) {
              // 情况1：没有absolute_percpu，所有符号用相对偏移
              offset = table[i].addr - relative_base;
              overflow = (offset < 0 || offset > UINT_MAX);
          } else if (symbol_absolute(&table[i])) {
              // 情况2：有absolute_percpu，且当前符号是percpu符号
              offset = table[i].addr;  // 直接存储绝对地址（正数）
              overflow = (offset < 0 || offset > INT_MAX);
          } else {
              // 情况3：有absolute_percpu，但当前符号不是percpu符号
              offset = relative_base - table[i].addr - 1;  // 编码为负数！
              overflow = (offset < INT_MIN || offset >= 0);
          }
          printf("\t.long\t%#x\n", (int)offset);
      }
  }
```

### 查找 kallsyms\_offsets 表的起始地址

通过代码分析我们知道了offsets表的结构，我们在内存中寻找连续 16 个 `int32`，它们必须满足“正整数”且“严格递增”。伪代码如下：

```c
address_t FindRelativeTableStart(address_t start_gva, address_t end_gva) {
    // 每次移动 4 字节（int32的大小）
    for (addr = start_gva; addr < end_gva; addr += 4) {
        int32* window = MapPage(addr);
        // 核心启发式规则：
        // 1. 连续 16 个数值
        // 2. 均为正数 (排除 Per-CPU 干扰)
        // 3. 严格递增 (V[i] < V[i+1])
        if (IsStrictlyMonotonicPositive(window, 16)) {
            // 这里极大概率是 offsets 表的起点
            // 为了保险，再向后校验一整页
            if (VerifyPageConsistency(addr)) {
                return addr;
            }
        }
    }
    return NOT_FOUND;
}
```

### 2\. 查找 kallsyms\_offsets 表的结束地址（同时确定 kallsyms\_relative\_base 和 num\_syms）

找到头部后，我们需要确定表在哪里结束。这比找头部更难，因为这里存在**Per-CPU 变量**的干扰。我的思路是：持续扫描，直到遇到一个值，该值被解释为 64 位指针时，恰好等于我们之前找到的内核基地址。 伪代码

```c
struct KsymInfo FindRelativeTableEnd(address_t start_addr) {
    address_t current = start_addr;
    bool in_percpu_zone = false;
    while (true) {
        int32 val = ReadInt32(current);
        // --- 核心终止条件 ---
        // 检查当前位置是否是 kallsyms_relative_base
        // 在相对模式下，offsets 数组紧接着就是 base 地址 (8字节)
        int64 potential_base = ReadInt64(current);
        if (potential_base == g_KernelBase) {
            // 找到了！结构闭环验证成功
            return {
                .offsets_end = current,
                .relative_base = potential_base,
                .num_syms = ReadInt32(current + 8) // base 后紧跟 num_syms
            };
        }
        // --- Per-CPU 容错逻辑 (Edge Case) ---
        // Per-CPU 变量可能导致偏移量出现 -1 (0xFFFFFFFF) 或乱序
        // 如果遇到连续的 -1，标记进入特殊区域，暂时放宽单调性检查
        if (val == -1 && ReadInt32(current + 4) == -1) {
            in_percpu_zone = true;
            current += 4; // 继续扫描
            continue;
        }
        current += 4;
    }
}
```

## 绝对地址模式

```c
//scripts/kallsyms.c中关于生成address的逻辑(5.4.150)
		} else if (!symbol_absolute(&table[i])) {
			if (_text <= table[i].addr)
				printf("\tPTR\t_text + %#llx\n",
					table[i].addr - _text);
			else
				printf("\tPTR\t_text - %#llx\n",
					_text - table[i].addr);
		} else {
			printf("\tPTR\t%#llx\n", table[i].addr);
		}
```

**核心特征**：

1. **数据宽度**：连续的 8 字节数据。
    
2. **值域约束**：所有的值必须是有效的内核指针（`0xffffffff...`），且大部分指向内核代码段头部（`_text` 附近）。
    
3. **终结符**：地址数组结束后，紧接的是 `num_syms`（符号数量），这是一个很小的整数。 伪代码
    

```c
struct KsymInfo FindAbsoluteTable(address_t start_gva) {
    address_t current = start_gva;
    address_t table_start = 0;
    // 阶段 1: 寻找连续的内核指针流
    while (current < g_RoDataEnd) {
        int64* window = MapPage(current);
        // 启发式规则：
        // 1. 连续 8 个 QWORD
        // 2. 全部是有效的 Kernel Pointer (最高位为1)
        // 3. 都在 .text 段范围内 (CodeStart ~ CodeEnd)
        // 4. 单调递增
        if (IsValidKernelPointerSequence(window, 8)) {
            table_start = current;
            break; // 锁定头部
        }
    }

    // 阶段 2: 寻找尾部 (num_syms)
    // 沿着指针流向后跑，直到遇到一个“异类”
    address_t scan_ptr = table_start;
    while (true) {
        int64 val = ReadInt64(scan_ptr);
        // --- 核心终止条件 ---
        // 如果遇到一个数值，它不是指针，而是一个合理的“符号数量”
        // (例如: 0 < val < 200,000)
        if (!IsKernelPointer(val) && val > 0 && val < MAX_SYMBOLS) {
            // 找到了 num_syms，意味着地址表结束
            return {
                .addresses_start = table_start,
                .addresses_end = scan_ptr,
                .num_syms = (int32)val
            };
        }
        scan_ptr += 8;
    }
}
```

## 剩余表的查找

在锁定了 `kallsyms_offsets` 之后，现在面临的是一片连续的、变长的、高度压缩的二进制数据流。这就是 `kallsyms_names`。为了能读懂这些参数，我们需要找到解压字典（Token Table）及其索引（Token Index）。

### 查找 kallsyms\_names 表的结束地址

`kallsyms_names` 是一个变长数组，无法简单地通过 `Base + Count * Size` 来计算结束位置，因为每个符号名的长度都不一样。 但是既然无法计算，那我们就必须模拟内核走一遍，利用之前获取的 `NumberOfNames` 作为计数器，模拟内核的遍历逻辑，逐个跳过符号条目。

```c
kallsyms_names格式：
          //   +--------+------------------+--------+------------------+
          //   | len(1) | encoded_name(len)| len(1) | encoded_name(len)|...
          //   +--------+------------------+--------+------------------+
address_t FindNamesTableEnd(address_t start_addr, int total_symbols) {
    address_t current = start_addr;
    byte* ptr = MapGuestPage(current);
    // 必须老老实实遍历完所有符号
    for (int i = 0; i < total_symbols; i++) {
        // 读取当前符号的长度 (第1个字节)
        byte len = *ptr;
        // 跳过当前符号 (长度字节 + 数据载荷)
        int step = 1 + len;
	    ptr += step; 
        current += step;
    }
    // 遍历结束的位置，就是 Names 表的终点
    // 同时也必然是 Markers 表的起点 (对齐后)
    return AlignUp(current, 8);
}
```

### 查找 kallsyms\_markers 表的结束地址

为了加速对变长压缩数据的访问，Linux 内核引入了 `markers` 表。它每隔 256 个符号记录一次偏移量。问题在于：`markers` 表本身也没有显式的长度字段。我们需要找到它在哪里结束，也就是 `token_table` 在哪里开始。 但是我们可以利用相邻两个内存区域的数据特性差异：

* **Markers 区域**：存储的是偏移量，数值通常较小（0 ~ 几百万），且呈递增趋势。
    
* **Token Table 区域**：紧随其后，存储的是压缩用的字符串片段（ASCII 数据）。如果将 ASCII 数据强行解释为整数，通常会得到巨大的、无规律的数值。 而且由于不同内核版本存储的字节大小不一样，两套判断逻辑：
    

1. **标准版 (8字节 Marker)**：只要读到的值 `> 0xFFFFFFFF`，就认为撞到了 Token Table（因为 Token 字符串的 ASCII 组合起来通常很大）。
    
2. **精简版 (4字节 Marker)**：用于 5.x+ 内核。由于数值变小，单纯看大小不可靠，改为检查**单调性破坏**或**剧烈跳变**。
    

```c
address_t FindMarkersEnd(address_t start_addr, bool is_reduced_mode) {
    address_t current = start_addr;
    while (true) {
        // 读取当前值和下一个值
        uint64_t val = ReadValue(current);
        uint64_t next_val = ReadValue(current + step_size);
        if (!is_reduced_mode) {
            // --- 旧内核策略 ---
            // 如果读到一个巨大的值 (大于 32位整数最大值)
            // 说明这不是偏移量，而是 Token Table 的字符串数据
            if (val > 0xFFFFFFFF) break; 
        } 
        else {
            // --- 新内核策略 (4字节) ---
            // 1. 递增性破坏：偏移量不可能变小
            if (val >= next_val) break;
            // 2. 剧烈跳变：两个 marker 之间不可能差太多
            // 0x3000 是一个经验阈值 (256个符号的压缩数据通常远小于此)
            if (next_val - val >= 0x3000) break;
        }
        current += step_size;
    }
    return current;
}
```

### 查找 kallsyms\_token\_index 表的起始地址

这是最困难的一步，我们找到了 `token_table` 的起点（紧跟在 markers 后面），但不知道它有多长。`token_index` 就在 `token_table` 后面。 问题在于

* 要找到 `token_index`，必须知道 `token_table` 的长度。
    
* `token_table` 是字符串堆，没有长度记录。
    
* `token_index` 是一个 `short` 数组，也没有固定特征。 s思路：虽然我们不知道 `token_index` 在哪里，但我们知道 `token_index` **里面存的是什么**！ `token_index` 的第 0 个元素，必定指向 `token_table` 的第 0 个字节；第 1 个元素，必定指向第 1 个字符串的开头……。这也就意味着我们可以构造模式匹配！！！
    

```c
address_t FindTokenIndexStart(address_t table_start) {
    // 1. 读取 Token Table 的头部数据 (前48字节)
    char buffer[48] = ReadMemory(table_start, 48);
    // 2. 构造“指纹” (Signature Generation)
    // 计算前 5 个 Token 的理论偏移量
    uint16_t signature[5];
    signature[0] = 0;
    int offset = 0;
    for(int i=1; i<5; i++) {
        // 计算上一个字符串的长度 (strlen)
        int len = StringLength(&buffer[offset]) + 1; // +1 for null terminator
        offset += len;
        signature[i] = offset;
    }
    // 此时 signature 可能为 {0x0000, 0x0001, 0x0007, 0x000E, 0x0016}
    // 3. 在内存中暴力搜索这个指纹
    // 搜索范围：假设 Token Table 不会超过 1页 (通常只有几百字节)
    address_t search_ptr = table_start;
    for(int i=0; i < 512; i++) { // 每次移动 8 字节
        uint16_t candidates[5] = ReadMemory(search_ptr, 10);
        // 比对内存中的数据和我们要找的指纹
        if (MemCmp(candidates, signature, sizeof(signature)) == 0) {
            // 找到了！这里就是 kallsyms_token_index 的起点
            return search_ptr; 
        }
        search_ptr += 8;
    }
    return ERROR_NOT_FOUND;
}
```

至于index表的结束地址，直接从开始地址往后读256个word大小就可以，原因是kallsyms使用1字节编码，最多256种token

# 3.不足点

## 现在的做法

我们的重构路径遵循了一条严密的**数据依赖链**，每一个步骤的输出都成为了下一个步骤的输入锚点：

1. **物理边界锁定**：
    
    * 利用 `MSR_LSTAR` 获取系统调用入口作为初始坐标。
        
    * 利用特征字符串定位 `.rodata` 及内核版本。
        
    * 利用发行版特征码回溯定位 `_text` 基址。
        
2. **寻址模式自适应**：
    
    * 通过统计学特征（单调性、数值范围）自动识别 Kallsyms 是采用 **绝对地址** 还是 **相对偏移**。
        
3. **压缩数据流解密**：
    
    * **Names 表**：模拟内核遍历逻辑，跳过变长数据，确定边界。
        
    * **Markers 表**：利用“数据纹理”差异（小整数偏移 vs ASCII 乱码），通过阈值检测和单调性破坏定位结束点。
        
    * **Token Index 表**：通过预读取 Token Table 头部数据，计算出前 5 个 Token 的理论偏移量，构建出独一无二的“二进制指纹”\*\*，从而在内存中精准定位 Token Index 的起始位置。
        

## 存在的缺陷

1.在嵌入式领域，自 2013 年起，OpenWRT 引入了一个名为 `kallsyms_uncompressed` 的补丁，这直接打破了我们对“符号表必然压缩”的固有认知。这会直接导致`kallsyms_token_table` 和 `kallsyms_token_index` 彻底消失，`kallsyms_names` 中直接存储明文 ASCII 字符串。

原因是为了配合整个内核镜像的 LZMA 二次压缩。虽然 kallsyms 自身的 Huffman 压缩能节省部分空间，但在更高效的 LZMA 全局压缩面前，预先的 Huffman 压缩反而破坏了数据的冗余度，导致最终生成的 LZMA 镜像变大。

2.linux6.x布局打乱 在 Linux 6.2 中，为了加速符号查找（特别是加速 `kallsyms_on_each_symbol` 等遍历操作），内核引入了 `kallsyms_seqs_of_names` 表。

```Plaintext
...
kallsyms_markers
kallsyms_seqs_of_names  <-- 新增插入点
kallsyms_token_table
...
```

而到了 Linux 6.4，情况变得更加棘手。内核为了优化初始化流程或数据段布局，将整个 Kallsyms 结构进行了倒置。

* **5.x 布局（旧）**：
    
    1. `kallsyms_addresses/offsets` (搜索入口)
        
    2. `kallsyms_num_syms`
        
    3. `kallsyms_names` ...
        
* **6.4+ 布局（新）**：
    
    1. `kallsyms_num_syms` (变成了开头！)
        
    2. `kallsyms_names`
        
    3. `kallsyms_markers`
        
    4. `kallsyms_token_table`
        
    5. `kallsyms_token_index`
        
    6. `kallsyms_addresses/offsets` (被扔到了最后！) 这意味着我们的入口锚点和校验逻辑同时失效
        

总结：内存取证与虚拟化安全的世界里没有**银色子弹**，任何基于经验的硬编码特征（Heuristics），在内核源码的某一次 Commit 面前都可能变得不堪一击。。